\begin{itemize}
	\item Fibonacci heap has best performance when insertion or union operations are performed as it is equivalent to adding a node to a doubly linked list and it takes constant time. Hence the best performance can be obtained from Fibonacci heap when the frequent requirement is to use only insert and union operation. It takes constant time $O(1)$ to perform these operations and this is the main reason Fibonacci heap is used frequently in Network optimization algorithms. Fibonacci heap has good performance even when it is used for decrease key operation where the key/data of a node is modified. Depending on the key/data of the parent node the restructure may or may not happen (heap order violation). If the restructure does not happen it is a $O(1)$ operation, but if the restructuring occurs then it's amortized cost is $O(1)$
	\item Fibonacci heap has a heap data structure similar to that of Binomial Heap, with slight modifications and a looser structure. Fibonacci heap defers from Binomial heap in the context of the consolidate operation which occurs only at the time of extract minimum and delete operation. Due to the deferred clean up, the worst case time complexity of delete and extract minimum operations is $O(n)$, however they are $O(\log{n})$ amortized. Hence the worst case performance for the Fibonacci heap is when delete operation or extract min operation are performed and the time bound would be $O(\log{n})$. 
	\item Fibonacci heap has average performance when major operation performed frequently is that of insert/union and decrease-key and we use delete and extract-min operation once in a while.
\end{itemize} 


